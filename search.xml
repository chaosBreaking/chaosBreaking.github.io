<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分布式领域CAP理论</title>
    <url>/2018/09/20/CAP_theory_of_distribution_system/</url>
    <content><![CDATA[<h1>分布式领域CAP理论</h1><p>Consistency(一致性)</p><blockquote><p>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）。数据一致更新，所有数据变动都是同步的。</p></blockquote><p>Availability(可用性)</p><blockquote><p>在集群中一部分节点故障后还能响应用户的读写请求。</p></blockquote><p>Partition tolerance(分区容忍性)</p><blockquote><p>以实际效果而言，分区相当于对通信的时限要求，系统如果不能在一定时限内达成一致，意味着发生了分区（分叉）的情况，必须就当前操作在C和A之间做出选择。</p></blockquote><a id="more"></a><p>CAP理论是说：在分布式存储系统中，最多只能实现以上两点。由于网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是一定要实现的。因此剩下的一个在C和A之间做权衡。 传统数据库支持ACID：</p><blockquote><p>A 代表原子性，即事务执行是原子性的，事务中的操作要么全部执行，要么完全不执行； C 代表一致性，即事务执行过程中整个数据库的状态是一致的； I 代表隔离性，即两个事务不会互相影响，覆盖彼此数据等； D代表持久化，事务一旦完成，数据应该是被写到安全的、持久化的存储设备上。</p></blockquote><h2 id="consensus">Consensus</h2><p>共识是分布式系统中的基本问题。共识涉及多个服务器就价值达成一致，一旦他们就价值作出决定，该决定就是最终决定。 共识通常出现在复制状态机的上下文中，这是构建容错系统的一般方法。每个服务器都有一个状态机和一个日志。状态机是我们想要容错的组件，例如哈希表。即使群集中的少数服务器发生故障，客户端也会看到他们正在与单个可靠的状态机进行交互。每个状态机都从其日志中获取输入命令。在我们的哈希表示例中，日志将包含set x to 3之类的命令。使用一致性算法来同意服务器日志中的命令。一致性算法必须确保如果任何状态机将set x应用为3作为第n个命令，没有其他状态机将应用不同的第n 个命令。结果，每个状态机处理相同系列的命令，从而产生相同系列的结果并到达相同的一系列状态。</p><blockquote><p>日志类似于Action，状态机类似于Block&amp;Chain。</p></blockquote><p>区块链要解决的问题是：共识问题和CAP问题</p>]]></content>
      <categories>
        <category>Distribution System</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>cap</tag>
        <tag>distribution</tag>
      </tags>
  </entry>
  <entry>
    <title>Note — Node.js设计模式(二)</title>
    <url>/2018/10/03/CPS/</url>
    <content><![CDATA[<h1>CPS(Continuation Passing Style)</h1><p>在JS中，回调是一个作为参数传递到一个函数的函数，当操作完成时将调用该结果。在函数式编程中，这种传播结果的方式称为<strong>CPS</strong>。这是个通用的概念，并不是总与异步操作相关联。其表示的是通过将结果传递给另一个函数(回调)而使结果传播，而不是直接返回给调用者。</p><a id="more"></a><p>##同步CPS</p><p>一个简单的同步函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见该函数使用return将结果返回给调用者，我们称此为<strong>Direct Style(直接风格)</strong></p><p>该函数等效的CPS写法是</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, callback</span>)</span>&#123;</span><br><span class="line">    callback(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其进行调用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, res =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: <span class="subst">$&#123;res&#125;</span>`</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure><p>因为add函数是同步的，所以结果是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">Result: 3</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p>这个add函数是一个同步CPS函数，意味着只有回调执行完成时它才返回值。</p><p>##异步CPS</p><p>改写上面的add函数使其成为异步的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncAdd</span>(<span class="params">a, b, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> callback(a + b), <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码通过调用setTimeout来模拟异步调用，接下来调用这个异步函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">asyncAdd(<span class="number">1</span>, <span class="number">2</span>, res =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: <span class="subst">$&#123;res&#125;</span>`</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure><p>通过运行之后发现结果是这样的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br><span class="line">Result: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可见在setTimeout函数触发异步操作后，asyncAdd函数立即返回，将控制权交回给事件循环以处理新事务。当异步操作完成时，从提供给异步函数的回调开始将重新启动该过程，从而引发退绕。执行将从事件循环开始，因此将有一个新的堆栈。由于是<strong>闭包</strong>，即使在不同时间的环境下调用回调函数也不用维护异步调用的上下文。</p><h2 id="同步或异步">同步或异步</h2><p>某些函数编写过程中可能会同时牵涉到异步和同步，就以书中例子来看</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[filename])</span><br><span class="line">        <span class="keyword">return</span> callback(cache[filename]);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            cache[filename] = data;</span><br><span class="line">            callback(cache[filename]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上代码可知，如果文件是缓存过的，那么这是一个同步调用，会立即执行callback。但如果文件没有缓存过，那么会调用异步操作来读取文件，直到readFile返回结果。</p><p>之后按照书中的例子，我们调用这个函数来创建一个文件读取监听器，当文件读取完毕时将调用所有的监听器。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileReader</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> listeners = [];</span><br><span class="line">    readFile(filename, value =&gt; &#123;</span><br><span class="line">        <span class="comment">//调用readFile并且给一个回调函数，使得读取文件后执行listeners里的所有回调函数</span></span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(value));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       	<span class="comment">//返回一个对象用来给外部注册监听器</span></span><br><span class="line">        onDataReady: <span class="function"><span class="params">listener</span> =&gt;</span> listeners.push(listener)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reader1 = createFileReader(<span class="string">'data.txt'</span>);</span><br><span class="line">reader1.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`first call data : <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">   <span class="keyword">const</span> reader2 = createFileReader(<span class="string">'data.txt'</span>);</span><br><span class="line">    reader2.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`second call data : <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用的结果是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first call data : somedata......</span><br></pre></td></tr></table></figure><p>分析第二个操作不会调用的原因：</p><p>1.在reader1的创建过程中，readFile函数以异步的方式运行，因为没有缓存的内容。因此有足够的时间来注册监听器，这些监听器在文件读取操作完成时在之后的另一个事件循环中将被调用。</p><p>2.在reader2的创建过程中，readFile函数是同步运行的，因为已经有了缓存。因此它会立即执行回调函数也就是createFileReader，那么所有的监听器也会被立即调用。而此时监听器并没有被注册(下一步的时候才注册reader.onDataReady...)，因此我们给reader2注册的监听器永远不会被调用。</p><p>因此归根结底，是因为readFile函数在不同情况下表现出不一致的行为，有时异步有时同步。这种令人难以捉摸的函数被类比为释放的Zalgo</p><h2 id="so">So?</h2><p>所以吸取教训，API必须保证其特性明确，要么同步要么异步。</p><p>那么有两种改写的思路：全同步或全异步</p><p>全同步的写法是</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileSync</span>(<span class="params">filename, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[filename])&#123;</span><br><span class="line">        callback(cache[filename]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cache[filename] = fs.readFileSync(filename, <span class="string">'utf8'</span>);	<span class="comment">//同步读取，没有回调函数</span></span><br><span class="line">        callback(cache[filename]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Node.js里同步无异于开历史倒车，同步的缺点太多所以我们改成完全异步。在Node.js里可以使用一个方法来延迟执行操作：process.nextTick()。它的作用是<strong>延迟一个函数的执行直到下一个事件循环的到来</strong>。它的功能就是将回调作为参数，将其推到事件队列的顶部，在任何待处理的IO事件之前返回。一旦事件循环再次运行，该回调回被执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileAsync</span>(<span class="params">filename, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[filename])&#123;</span><br><span class="line">        process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(cache[filename]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fs.readFile(filename, <span class="string">'utf8'</span>, (error, data) =&gt; &#123;</span><br><span class="line">            cache[filename] = data;</span><br><span class="line">            callback(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个函数将会始终表现为异步执行。</p><p>另一个用于延迟执行代码的API是setImmediate()。它与process.nextTick()作用相似，但语义是完全不同的。</p><p>process.nextTick()延迟的回调在任何已经调度的IO之前运行，在某些情况下可能会导致IO饥饿（回调插队导致IO任务没有被安排，使得IO空闲），例如递归调用。</p><p>setImmediate()延迟的回调将在队列中已有的任何IO事件后排队。</p><h2 id="node-js回调约定">Node.js回调约定</h2><ul><li><p>回调函数置尾</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(filename, <span class="string">'utf8'</span>, callback)</span><br></pre></td></tr></table></figure></li><li><p>暴露错误优先</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        errorHandler(err);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        processData(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>传播错误</p><p>在异步CPS风格中，可以将错误简单的传播到链中的下一个回调来进行处理，但是要用return。类似于</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">return</span> callback(err)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>未捕获的异常</p></li></ul>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>CPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Note — Node.js设计模式(四)</title>
    <url>/2018/11/20/Factory/</url>
    <content><![CDATA[<h1>工厂模式</h1><p>工厂模式允许我们将对象的创建从实现中分离出来。从本质上来说，工厂方法包装了一个新实例的创建，这给了我们很大的灵活性。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span>(<span class="params">imageName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(imageName.match(<span class="regexp">/\.jpeg$/</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jpegImage(imageName)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(imageName.match(<span class="regexp">/\.gif$/</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> gifImage(imageName)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(imageName.match(<span class="regexp">/\.png$/</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> pngImage(imageName)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">'Unsupported format'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，createImage就是一个&quot;图片工厂&quot;，负责由给入的参数来生成具体的图像实例，如果我们要支持新的图片格式，只需要修改该工厂函数即可完成扩展。</p><p>**工厂模式允许我们不暴露创建对象的构造函数，避免其被继承和修改，符合了小暴露原则。</p><h2 id="一种封装的机制">一种封装的机制</h2><p>得益于闭包，工厂方法也可以用来进行功能的封装。</p><blockquote><p>**封装（encapsulation）**是指通过阻止外部代码直接操作对象来控制访问内部细节的技术。只能通过公共的接口与对象进行交互，将外部代码和对象内部运行的细节隔离开来。这种做法也被称作信息隐藏。与继承、多态和抽象一样，封装也是面向对象设计的基本准则。</p></blockquote><p>Javascript没有访问级别的修饰符（比如无法申明一个私有变量），所以实现封装的唯一方式是函数作用域和闭包。使用工厂方法来实现私有变量是非常直接的，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> privateProperties = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> person = &#123;</span><br><span class="line">        setName: <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!name) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'A person must have a name'</span>);</span><br><span class="line">            privateProperties.name = name;</span><br><span class="line">        &#125;,</span><br><span class="line">        getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> privateProperties.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码利用闭包创建了两个对象，一个是返回的person对象，另一个是包含不能被直接访问的私有属性的privateProperties，内部的属性只能通过提供的setName和getName方法来修改和访问。</p><h2 id="可组合的工厂函数">可组合的工厂函数</h2><p>可组合的工厂函数是一类特殊的工厂函数，他们可以被组合到一起来构建新的增强的工厂函数。当我们想要创建从多个源继承一些行为和属性的对象，却不想构建复杂的类结构时就可以使用组合工厂函数。</p><p>可以用一个简单的例子来阐释组合工厂函数，需要引用stampit模块。该模块本质上允许我们通过一个方便的接口来定义工厂函数，使生成的对象拥有一系列特定的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stampit = <span class="built_in">require</span>(<span class="string">'stampit'</span>);</span><br><span class="line"><span class="keyword">const</span> character = stampit(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="string">'Anonymous'</span>,</span><br><span class="line">    lifePoint: <span class="number">100</span>,</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> mover = stampit(&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    move(x, y) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x += x;</span><br><span class="line">      <span class="keyword">this</span>.y += y;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved to (<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> shooter = stampit(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    bullets: <span class="number">6</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    shot() &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.bullets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'run out of bullets'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.bullets -= <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> shooted`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码利用stampit创建了三种基本类型分别是人物，可行走的人物和可射击的人物。接下来我们创建一个组合类，其实例拥有人物属性，可以行走和射击。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Player = stampit.compose(character, mover, shooter);</span><br><span class="line"><span class="keyword">let</span> player1 = Player()</span><br><span class="line">player1.name = <span class="string">'kimmy'</span>;</span><br><span class="line">player1.move(<span class="number">1</span>,<span class="number">1</span>);	<span class="comment">//kimmy moved to (1,1)</span></span><br><span class="line">player1.shot();		<span class="comment">//kimmy shooted</span></span><br></pre></td></tr></table></figure><p>通过stampit的compose方法，我们可以将基本类型进行组合，从而创建出具有三者属性和方法的新类型Player。</p>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Note — Node.js设计模式(三)</title>
    <url>/2018/10/03/Module/</url>
    <content><![CDATA[<h1>require函数</h1><p>##构成</p><ul><li>resolve	模块路径解析函数，根据传入的模块名来解析出完整路径。</li><li>main</li><li>extensions</li><li>cache 模块缓存，以模块的<strong>完整路径</strong>和<strong>该模块的Module对象</strong>作为K-V存储。</li></ul><a id="more"></a><p>##导入模块</p><p>1.接受模块名称作为输入，使用require.resolve()来完成路径解析</p><p>2.如果模块已经在缓存中，则立刻返回(require.cache里模块的路径<id>作为键的对象)</id></p><p>3.如果模块未被加载，需要为首次加载设置运行环境。将会创建一个Module对象，其中包含用控对象字面量初始化的exports属性。此属性将用于模块的代码到处公共API。</p><p>4.Module对象被缓存</p><p>5.模块源代码被读取和评估,将module.exports的内容表示模块的API，返回给调用者</p><h2 id="module">module</h2><p>定义一个模块，要导出的部分需要被分配给module.exports，不然该模块下的内容都是私有的。但是，模块系统暴露了global这个特殊的变量，也就是说在一个模块里对于global的操作会污染导入它的模块的global变量。</p><h2 id="解析算法">解析算法</h2><p>解析算法可以分为以下三个部分：</p><ul><li><p>文件模块：若以/开头，则被视为绝对路径，将按照原样返回；若以./等开头则视为相对路径</p></li><li><p>核心模块：如果模块名之前没有/等则会在Node.js核心模块中搜索</p></li><li><p>包模块：如果在核心模块中没有找到，则会在第一个node_modules中查找匹配的模块目录，它从所需模块开始在目录结构中向上导航。该算法通过超找目录书中的下一个node_modules目录继续搜索匹配，知道文件系统的根目录。</p></li></ul><p>对于文件和包模块，单个文件和目录都可以与moduleName相匹配。算法将会尝试匹配以下内容：</p><ul><li><p><modulename>.js</modulename></p></li><li><p><modulename>/index.js</modulename></p></li><li><p>在<modulename>/package.json的main属性中指定的目录/文件</modulename></p></li></ul><p>每个包都有自己的私有依赖，这保证了应用中不存在版本兼容性的冲突问题。</p><h2 id="模块缓存">模块缓存</h2><p>每个模块只在第一次需要时才被加载和评估，后续都将返回缓存的版本。</p><p>产生的影响：</p><ul><li>使得模块依赖项中可以有循环。</li><li>在某种程度上保证，在给定包中需要相同的模块时总是返回相同的实例。</li></ul><h2 id="循环依赖">循环依赖</h2><p>在a.js中引用b.js，同时在b.js里引用a.js</p><p>之后在第三方main.js里引用二者。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br></pre></td></tr></table></figure><p>结果是，b.js里引用的a.js不完整，它的状态是到达引用b.js那一刻的状态。</p><h1>模块定义模式</h1><p>模块系统是用于定义API的工具。API设计主要是考虑私有和公有功能之间的平衡。目标是最大限度的实现隐藏信息和API可用性，同时平衡这些问题与其他软件的质量问题，如可扩展性(extensibility)和代码重用(code reuse)。</p><p>几种流行的模块定义模式</p><h2 id="命名导出">命名导出</h2><p>暴露公共API最基本的方法，将所有要公开的值赋给由exports（或module.exports）引用对象的属性。</p><p>CommonJS规范仅允许使用exports变量来公开公共API，因此命名导出模式是唯一真正与CommonJS规范兼容的模式。module.exports是Node，js提供的一个扩展，用以支持广泛的模块定义模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//logger.js</span></span><br><span class="line">exports.info = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`info <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'./logger.js'</span>);</span><br><span class="line">logger.info(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><h2 id="导出函数">导出函数</h2><p>将整个module.exports重新分配给一个函数。主要优点是只暴露一个单一的功能，给模块提供了一个明确的入口点。也很好的遵循了*小接触面(small surface area)*原则。同时以主要导出的函数作为其他API的命名空间，我们可以扩展次要或更高级的模块.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//logger.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`info: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export.error = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'./logger.js'</span>);</span><br><span class="line">logger(<span class="string">'hello'</span>);</span><br><span class="line">logger.error(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure><p>单一责任原则（Single Responsibility Principle ,SRP）：</p><blockquote><p>每个模块应该对单个功能负责，该责任应完全由模块封装。</p></blockquote><h2 id="导出构造函数">导出构造函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//logger.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Logger.prototype.info = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`info: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">Logger.prototype.error = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------- es6 --------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    info(msg)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`info: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    error(msg)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Logger;</span><br></pre></td></tr></table></figure><p>以下改进可以防护不使用new指令调用，甚至可以模块作为工厂来使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Logger))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Logger(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> Logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>);</span><br><span class="line"><span class="keyword">const</span> dbLogger = Logger(<span class="string">'DB'</span>);</span><br></pre></td></tr></table></figure><p>在ES6里有一个语法糖new.target，这是在所有函数里提供的meta属性，如果使用new关键字调用函数，则new.target的值为true。上面的代码可以改写为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">new</span>.target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Logger(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导出实例">导出实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Fun.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Fun(<span class="string">'joe'</span>)</span><br></pre></td></tr></table></figure><p>这种导出模式类似于创建<em>单例(singleton)</em>，然而因为在整个应用程序内该模块可能多次被安装所以并不能保证在应用程序内的唯一性。</p><h2 id="修改其他模块或全局作用域">修改其他模块或全局作用域</h2><p>猴子补丁*（monkey patching）*</p><blockquote><p>一个能修改其他模块或全局作用域对象的模块。通常是指在运行时修改现有对象以更改或扩展其行为或应用临时修复的做法。</p></blockquote><p>一个模块可以没有任何导出，其仍然可以修改全局作用域及其中的任何对象，包括缓存中的其他模块。这通常是不安全和不好的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Fun.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Fun(<span class="string">'joe'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//patch.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./m'</span>).eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eated'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line">f = <span class="built_in">require</span>(<span class="string">'./fun.js'</span>);</span><br><span class="line">f.eat(); 	<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'patch.js'</span>);</span><br><span class="line">f.eat();	<span class="comment">//eated</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title>Note — Node.js设计模式(一)</title>
    <url>/2018/10/03/Node-Reactor/</url>
    <content><![CDATA[<h1>事件循环</h1><p>​处理事件多路分解器返回的每个事件。与此同时，保证准备好和每个事件相关联的资源以被读取并且在操作期间不被阻塞。当处理完所有事件后，流再次阻塞事件多路分解器，直到有新的事件再次可用于处理。</p><blockquote><p>事件多路分解器: ​ 此组件收集并排列一套被监视的资源的IO事件，并阻塞他们，直到有新的事件来处理。</p></blockquote><a id="more"></a><h1>Reactor模式</h1><ul><li><p>主要思想</p><p>让每个IO事件与其处理程序关联（在Node.js里就是回调函数），在事件循环产生并发处理时立即调用相应的处理程序。</p></li><li><p>核心定义 ​ 通过阻塞来处理IO，直到一组被观察资源的新事件可用，然后将每个事件分派到相关联的处理程序来作出反应。</p></li><li><p>步骤</p></li></ul><p>1.应用程序向<strong>Event Demultiplexer</strong>（事件多路分解器）提交请求来生成新的IO操作。并且应用程序指定一个回调处理程序，当IO操作完成时立即调用处理程序。 提交请求是一种非阻塞过程，会立即将控制权返回给应用程序。</p><p>2.当一组IO操作完成时，<strong>Event Demultiplexer</strong>（事件多路分解器）将新的事件推入<strong>EventQueue</strong>（事件队列）。</p><p>3.此时<strong>Event Loop</strong>遍历<strong>Event Queue</strong>的项目，对每个事件调用其对应的处理程序。</p><p>4.处理程序是应用程序的一部分，它执行完后会将控制权交还给<strong>Event Loop</strong>。但是在执行处理程序的过程中可能会请求新的异步操作，从而新的操作被插入<strong>Event Demultiplexer</strong>，也就是第一步的过程。</p><p>5.当Event Queue项目都被处理完时，循环将阻塞<strong>Event Demultiplexer</strong>，直到有新的事件可用时，触发另一个周期。</p><p>与Reactor(反应器)模式对应的是Proactor(主动器)模式</p>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Note — Node.js设计模式(五)</title>
    <url>/2018/11/24/Proxy/</url>
    <content><![CDATA[<h1>代理模式</h1><p>代理（proxy）是一个用来<strong>控制</strong>对另一个对象（<strong>本体</strong>）访问的<strong>对象</strong>。它实现了与本体对象相同的接口，我们可以对两个对象进行随意的替换使用，也可以把这种模式称为替代模式。代理对象可以拦截所有或者部分 本来要对本体对象 执行的操作，补充或增强它们的行为。</p><blockquote><p>我们讨论的代理模式不是类之间的代理，代理模式指的是<strong>封装本体对象的真实接口</strong>，从而保持其内部状态。</p></blockquote><a id="more"></a><p>代理模式在某些场景下十分有用，比如</p><ul><li>**数据验证：**代理对象在将输入传递给本体对象之前先进行校验。</li><li><strong>安全性：</strong> 代理对象会校验客户端是否被授权操作本体对象。</li><li><strong>缓存：</strong> 代理对象内部维护一个缓存系统，当需要访问的数据不在缓存时才将操作传递到本体对象。</li><li><strong>延迟初始化：</strong> 如果对本体对象的创建是非常耗费时间和空间的，代理对象可以延迟其创建时机。</li><li>**日志：**代理对象拦截调用的方法和参数并将他们记录下来。</li><li><strong>远程对象代理：</strong> 代理对象可以为远程对象提供本地代表，就像调用本地对象。</li></ul><h2 id="实现代理模式的方法">实现代理模式的方法</h2><p>当我们要代理一个对象的时候，可以选择拦截其所有方法或者部分方法，将其余的方法直接委托给本体。</p><h3 id="1-对象组合">1.对象组合</h3><p>组合是指一个对象为了扩展其自身功能或者使用其他对象的功能，将另一个对象合并进来。对于代理模式来说，我们创建一个拥有和本体对象相同接口的新对象，并且以实例变量或闭包变量的形式引用存放在代理内部的本体对象。可以在客户端初始化时注入本体对象或者由代理对象来创建。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取本体对象的原型</span></span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(subject);</span><br><span class="line">  <span class="comment">//代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Proxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Proxy</span>.prototype = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">  <span class="comment">//代理方法</span></span><br><span class="line">  <span class="built_in">Proxy</span>.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subject.hello() + <span class="string">' World!'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//委托给本体对象的方法</span></span><br><span class="line">  <span class="built_in">Proxy</span>.prototype.goodbye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subject.goodbye.apply(<span class="keyword">this</span>.subject, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(subject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createProxy</span><br></pre></td></tr></table></figure><p>上例拦截了本体对象的hello方法，将goodbye方法委托给本体对象。</p><p>上例为了维护原型链正确，使用了伪继承的方法，如果不需要就可以使用更直接的方法，如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy2</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    hello: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> subject.hello() + <span class="string">'World'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    goodbye: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> subject.goodbye.apply(subject, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对象增强-object-augmentation">2.对象增强（Object augmentation)</h3><p>对象增强（或者叫monkey patching)通过替换本体对象方法的方式来实现代理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy3</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> orihello = subject.hello;</span><br><span class="line">  subject.hello = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orihello.call(<span class="keyword">this</span>) + <span class="string">'World'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比以上两种方法，对象组合是创建代理最安全的方法，保证了本体对象无法被外部访问，本体对象的原始行为不会被改变。但是如果只想代理某一个方法，需要将剩余所有的方法委托给本体对象。</p><p>对象增强修改了本体对象，但是并没有委托相关的各种不便。在不太关注是否修改本体对象的情况下，对象增强是最实用的方法。</p><h2 id="生态系统中的代理模式-函数钩子与面向行为编程-aop">生态系统中的代理模式——函数钩子与面向行为编程（AOP）</h2><p>代理模式多种多样，在Node.js及其生态系统中非常常见。我们可以找到一些帮助简化创建代理对象的库。其中大部分都使用了对象增强的方式。在社区中，这一模式也被称为<strong>函数钩子（function hooking）</strong>,或者有时也被叫做<strong>面向行为编程（AOP）</strong>，实际上这也是代理模式的一个常用领域。在AOP模式中，这些库允许开发者为某一或某一系列方法设置pre或者post钩子，在指定方法运行前或者运行后可以执行自定义的代码。</p><p>有些时候代理也被称为<strong>中间件</strong>，因为该模式在中间件模式中很常见，它允许我们对一个函数的输入和输出进行预处理或者后处理，代理模式还允许使用类似中间件管道的方式来为同一个方法注册多个钩子。</p><h2 id="es2015中的proxy对象">ES2015中的Proxy对象</h2><p>ES2015规范引入了一个全局对象Proxy，Node.js从V6版本开始支持它。Proxy提供的接口包括一个构造函数，接受<strong>target</strong>和<strong>handler</strong>作为参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>target表示需要被代理的对象（本体对象），handler是用来<strong>定义代理行为</strong>的特殊<strong>对象</strong>。</p><p>handler对象包含了一系列预先定义好名称的可选方法，例如apply,get,set和has。这些方法被称作<strong>捕获方法（trap methods）</strong>，当代理对象实例在执行某些操作时就会自动被调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> brands = &#123;</span><br><span class="line">  car: <span class="string">'volkswagon'</span>,</span><br><span class="line">  drink: <span class="string">'coca cola'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> uppercaseBrands = <span class="keyword">new</span> <span class="built_in">Proxy</span>(brands, &#123;</span><br><span class="line">  <span class="keyword">get</span>: (target, property) =&gt; target[property].toUpperCase()</span><br><span class="line">&#125;);</span><br><span class="line">console.log(uppercaseBrands.car, uppercaseBrands.drink);	//VOLKSWAGON COCA COLA</span><br></pre></td></tr></table></figure><p>如上例所示，使用Proxy提供的方法拦截了所有目标对象，也就是对brands对象属性的访问，并将其属性值转换为大写字符串。</p><p>这种方法可以拦截和自定义很多对对象的操作，对一些场景如 <em>元编程</em>（meta-programming）、*操作符重载（operator-overloading）<em>和</em>对象虚拟化（object virtualization）*提供了很好的支持。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evenNumbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>([], &#123;</span><br><span class="line">  <span class="keyword">get</span>: (target, index) =&gt; index * 2,</span><br><span class="line">  has: (target, number) =&gt; number%2 === 0 </span><br><span class="line">&#125;);</span><br><span class="line">console.log(evenNumbers[0],evenNumbers[1],evenNumbers[2])	//0 2 4</span><br><span class="line">console.log(1 in evenNumbers, 2 in evenNumbers)				//false true</span><br></pre></td></tr></table></figure><p>上例创建了一个包含偶数的数组，利用的就是Proxy的特性。我们用Proxy代理了一个空数组，在handler中定义了<strong>get</strong>和<strong>has</strong>两个<strong>捕获方法</strong>。</p><ul><li><p><code>get</code>方法拦截了对数组元素的访问，并根据指定的索引返回特定的偶数。</p></li><li><p><code>has</code>方法拦截了对in操作符的使用，并检查给定的数是否为偶数。</p></li></ul><p>Proxy API还提供了很多其他的捕获函数，例如set、delete和construct。</p>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>构建一种面向应用的区块链底层</title>
    <url>/2018/09/28/TAC-APP-Token/</url>
    <content><![CDATA[<p>       以太坊希望将底层的区块链作为操作系统，在其之上运行一切DAPP。这个想法很宏伟和激动人心，但是从现在的情况来看，无需去再一次提及其性能如何，单就讨论在其上发布和运行的各种无用和毫无疑义的智能合约吞噬了主网资源，甚至一度使其瘫痪。这不应该是其所谓的&quot;世界计算机&quot;应该有的表现。至于后来发布的Sharding、Casper、Plasma等技术手段来提高主链性能的方式也并不能掩盖其设计的一些问题。从本质上来说，除了链即服务以外，像以太坊的这种形式来实现区块链应用落地是不现实的。下文就以几个出现在现有以太坊体系上的问题作为开端，对其设计的不合理性作以详细说明以及由此提出更好的方案。</p><a id="more"></a><h1>当前的问题</h1><h2 id="以太坊智能合约的实用性问题">以太坊智能合约的实用性问题</h2><p>       首先来聊聊智能合约吧，智能合约之父Nick Szabo关于智能合约的设想<a href="http://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html" target="_blank" rel="noopener">The Idea of Smart Contracts </a>并不是非常完善和具有概括性，以下文字很好的诠释了智能合约：</p><blockquote><p>一个智能合约(Smart contract)是一个计算化交易协议，用来执行合约条款。智能合约设计的通常目的是为了满足一般的合同条件(譬如支付条款，扣押令，私密性，甚至是执法)，最大限度减少恶意和意外的状况，最大限度减少使用信任式中间媒介。相关的经济目标包括降低欺诈损失，仲裁和执法成本，还有其它的交易成本。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><p>       可以说智能合约是一套 代码化的<strong>约定—执行</strong>体系 。如上所述其设计的目的也是为了满足一般的合同条件，那这样的约束就将智能合约在现实世界的作用和应用范围缩小了很多。很多情况下智能合约都不能接受外部世界的状态，原因是可信程度。就拿最常被举的例子：一位老人想要智能合约帮他完成过世后遗产的继承。这种事件的处理在现实世界十分顺畅和简易，只需要照着老人的遗嘱走法律程序即可。那么在没有现实世界法律体系的智能合约上该怎么处理呢？按照把大象放进冰箱的步骤走，应该是在某个时刻外部触发这份合约执行，合约通过判断是否达成条件来执行合约。那么问题来了，如何判断他本人过世这一条件是否达成？这个API来自什么地方，是否可信？最无解的地方就在这里，想要抛弃现实世界可能造假的传统合约而特立独行的智能合约在这里只能向外部世界妥协求援。好了，在这里就可以结束这场闹剧了。或许智能合约的拥护者应该已经将上面的例子吐槽千百遍。如果这种场景需要用到智能合约，那么最好有预言机(Oracle)的存在。前面大费周章的举出这么一个老掉牙的例子，是为了说明智能合约在如今并不能广泛的应用到很多领域，而这也恰恰是一众区块链项目所吹嘘的伟大的、革命性的东西。显然I don't buy it! 看看以太坊上所有的智能合约都能做什么吧，除了五花八门的ICO合约和许多类似于Fomo3D这类考验人性游戏类合约外可以说都是一堆复制了ERC20标准到处乱贴的垃圾代码。实用性在除了ICO和自嗨的以太坊狂热者自身之外的地方没有任何体现。</p><h2 id="evm存在的合理性和必要性">EVM存在的合理性和必要性</h2><p>       这个问题要在不同的场景下讨论，假如EVM是用来实现 以太坊和一众信徒所期待的那个智能合约 这一场景来看，EVM是一个会让所有人失望的东西。因为图灵完备的EVM却遇到了作用域十分有限的智能合约，图灵完备并不能让EVM能够达到大家所期望的智能合约应有的效果，尤其是为了防止合约代码死循环而设定的执行步骤限制，也就是Gas系统。还有以太坊对于合约逻辑和最终合约交易执行的捆绑，这些都让智能合约止步于非常有限的操作。可以说EVM是一个 因未来的智能合约可能需要 而催生出来但是却被捆绑着的DSL，华丽而且无用。如果在承认了智能合约的作用域十分有限的情况下，EVM应该尽可能的简化，砍掉一些编程方面的灵活性而加入模块化的设计，做到更加方便、简洁和安全。当然很多人不会对EVM和智能合约死心，那就再谈以太坊智能合约体系的真正软肋：合约在发布那一刻就已经死去。</p><p>       目前以太坊智能合约的设计将通证和业务逻辑紧紧捆绑在所谓的智能合约里，极大制约了业务本身的拓展和升级，甚至我们可以说，以太坊的智能合约强迫开发者在发布他们的合约时预知和决定未来的一切。显然这是不合理的代码独裁，这种冷冰冰的设计有着其独到的见解但也高傲和愚蠢，开发者必须戴着镣铐跳舞还要表现出享受的姿态，仿佛一旦你不称赞或者认同这种为了去中心化而作出的僵硬设计你就会被踢出区块链的世界。另一方面，以太坊主网本身要承载所有合约的执行，这种情况的确是符合区块链教义的。为此付出的代价就是，主网资源的巨大牺牲。要知道比起以太坊本身的交易，那些智能合约代码所要耗费的计算资源的确大了很多。</p><p>       综合上面所说的情况，可以解释部分”以太坊上的智能合约为何都是一些鸡肋无用的小把戏“这一情况了。</p><h2 id="理想的情况">理想的情况</h2><p>       区块链应用该以什么形式出现，以太坊已经举了反例。其实在区块链应用方面，IBM的Farbic给了我们很好的启示和可借鉴的地方，当然也有其不足之处。在Fabric里，通证和业务逻辑的耦合不再那么紧密，出现了链代码这个概念。如果说智能合约真的能成为极客和大众所期望的形式，一种妥协的、可能的实现办法就是链代码形式。首先链代码确保了能够真正实现业务逻辑而非被（因为安全而设计却又无法保证安全的）智能合约语言紧紧束缚，并没有实质性的功能。比起遵循死板的某种DSL，区块链更应该作为可信的价值体系来帮助重构一些已经存在的业务。应该尊重业务，跟业务很好的分割开来。区块链和应用的耦合关系应该从代码逻辑和通证体系分开来看。运行区块链主网的节点负责的是承载应用以及作为主网价值的维护者，而具体的业务需要专门的链代码来处理。而通证则是一条维系着区块链和传统业务的纽带。所形成的整个业务体系就像传统软件设计的理念一样，高内聚，低耦合。这样来看区块链应该是一个第三方的模块，很容易融入业务体系，而不是作为一种颠覆性的、破坏性的平台，要求所有业务搬迁到链上。现有的应用绝对不会交出用户交出流量向现有千千万万企图成为底层操作系统的公链妥协。</p><h2 id="一种面向业务的区块链应用体系设计">一种面向业务的区块链应用体系设计</h2><p>       Talk is cheap , show me something useful !<br>       个人认为，在区块链体系里构建一种高可用性应用应该遵循的理念是：节点承载应用，应用产生社群，社群反作用于体系而形成 <strong>链—应用—社群</strong> 的闭环，这样才有利于区块链形成真正的生态而非冷酷的代码独裁。</p><blockquote><p>节点：TIC主链节点<br>应用：DAPP（执行特定逻辑的链代码，和某种资产进行交互）</p></blockquote><p><img src="/images/image-20181012122351796.png" alt="image-20181012122351796"></p><p>       在一个具体的业务场景里，整个体系分成区块链底层和应用层。区块链底层负责构建去中心化的价值网络，拥有主链唯一的通证，作为唯一的可信价值代表。同时，承载一切形式的通证发行，包括utility token 、security token等，作为业务和应用的价值代表，流通在对应的业务体系中，可以享受到区块链的一切特性。在Bancor协议的支持下，非主链通证可以跟主链货币进行有价值依靠的转换，实现了一种主链体系下的跨链操作，与此同时跨业务的通证交换和流转也能轻松进行。最后，区块链底层的非主链通证向外部提供必要的API用于交互。应用层作为业务逻辑的主要实现，需要有其具体的程序，通过调用区块链提供的对应通证操作API来将通证纳入到应用中来，使应用对通证的操作就像操作数据库一样。业务逻辑编写完成后，将整个代码发布到区块链网络中进行部署。这一步如同以太坊合约发布一样，需要缴纳手续费，但是与之不同的是运行主网的节点有选择是否接受的权利，符合区块链原则、100%见证的应用需要达成一定的条件让全网来接受，除此之外的应用可以付出一定的报酬来吸引愿意安装的节点安装并向外界提供应用的服务，尽管这样的设计牺牲了可信度，就像一些区块链项目的侧链一样，但是这种设计类似于联盟链，联盟链是被人们所认可和接受的，况且这只是是可选情况之一。</p><p>       从具体的操作上展开，一个区块链应用，或者说一个包含通证体系的业务构建，在区块链上的操作主要包括以下三个过程：</p><h3 id="逻辑链层的搭建">逻辑链层的搭建</h3><p>       链层类似于以太坊的智能合约、Fabric的链代码，用来实现具体业务操作。</p><blockquote><p>租赁节点（服务器）类似于租赁服务器等计算资源。<br>部署链代码（程序）将应用程序发布到区块链网络，等待节点部署，根据达成条件的不同，可能为全网部署，也可能是部分节点部署。</p></blockquote><h3 id="通证的发布">通证的发布</h3><p>       TIC体系下的通证，如果是符合Bancor协议的本质可交易通证，默认锚定TIC。一方面增加了通证的实用性，另一方面为跨链带来一条可能途径。</p><blockquote><p>发行通证需要锚定到TIC（默认），规定发行量、精度等通证参数。</p></blockquote><h3 id="链层和通证的耦合">链层和通证的耦合</h3><p>       通证可以抽象为数据库，所有链逻辑最终进行的操作本质上是传统数据库的CRUD操作。因此我们对建立在TIC体系的通证进行统一化的抽象和封装，暴露出三个编程接口：查询(retrive)/兑换(exchange)/转移(transfer)。链代码通过调用上述接口即可完成对通证的操作，就完成了业务逻辑。链和通证的耦合需要通过公钥加密体系来认证，认证通过后可以将通证挂载在链上。</p><blockquote><p>挂载：每个通证都会注册在主链上，链注册在部分节点上，每个链对应一个地址（类比于ERC20的合约体系），将指向通证的事务转发给对应的链便是完成了把通证挂载在链上。当挂载成功后，主链会将指向通证的内部事务（查询/转移）转发给注册在该节点上的链，主链只处理外部事物（兑换）。</p></blockquote><p><img src="/images/TAC-APP-Token.png" alt="77924304.png"></p><p>       这个想法还有不成熟和不周到的地方，比如非主链通证的安全性、处理链代码的升级带来的负面影响等，欢迎批评指正。如果对于我的想法有更深入的理解和有趣的建议请联系我或者评论留言 ：）当然也欢迎打赏 ：P</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><em>The New Palgrave: Allocation, Information, and Markets</em> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>token</tag>
        <tag>DAC</tag>
      </tags>
  </entry>
  <entry>
    <title>可验证随机函数VRF</title>
    <url>/2018/11/21/VRF/</url>
    <content><![CDATA[<h2 id="哈希函数：">哈希函数：</h2><p>Result = HASH(Info)</p><h2 id="带密钥的哈希函数：">带密钥的哈希函数：</h2><p>Result = HASH(PrivateKey, Info)</p><a id="more"></a><p>带密钥的哈希函数，通过私钥和源信息产生散列值。所以在仅仅已知源信息的情况下无法得到与带密钥哈希函数所产生的相同的散列值。</p><p>但是有些情况下，需要验证某个未知<em>私钥</em> 的加密哈希函数的<em>输出</em>（Result）是否匹配于<em>源信息</em>（Info），此时就需要可验证的加密函数（VRF）来解决。</p><p>在VRF情形中，产生散列值的函数记为VRF_HASH，产生证明的函数记为Proof_HASH。验证过程中，由Proof计算出Hash的函数记为VRF_P2H，用来验证Info，PublicKey和Proof的函数记为VRF_Verify。</p><p>生成过程如下：</p><ol><li>Result = VRF_HASH(PrivateKey, Info)</li><li>Proof = VRF_Proof(PrivateKey, Info)</li><li>将Result，Proof，Info，PublicKey向外公布</li></ol><p>验证过程如下</p><ol><li>计算VRF_P2H（Proof）并与Result比较是否一致</li><li>计算VRF_Verify(PublicKey, Info, Proof)是否为True</li></ol><p>通过计算Proof是否是通过Info生成的，Proof计算出Result，Info和Result是否匹配，Proof作为中间桥梁。</p>]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript的call和apply方法</title>
    <url>/2018/11/23/js_call&amp;apply/</url>
    <content><![CDATA[<p>每个<strong>函数</strong>都具有两个非继承而来的方法，call和apply。</p><p>call和apply的作用一样，在特定的作用域调用函数，改变函数<strong>内部</strong>this指向，扩充函数依赖的作用域。</p><p>this一般指向调用某个方法的<strong>对象</strong>，使用call和apply方法就可以改变this的指向。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">redLight = &#123;</span><br><span class="line">  color: <span class="string">'red'</span></span><br><span class="line">&#125;;</span><br><span class="line">blueLight = &#123;</span><br><span class="line">  color: <span class="string">'blue'</span></span><br><span class="line">&#125;;</span><br><span class="line">color = <span class="string">'white'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Light</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Lighting --- use color <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span>`</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Light();				<span class="comment">//Lighting --- use color white</span></span><br><span class="line">Light.call(redLight);	<span class="comment">//Lighting --- use color red</span></span><br><span class="line">Light.apply(blueLight);	<span class="comment">//Lighting --- use color blue</span></span><br></pre></td></tr></table></figure><h2 id="不同点-apply和call接受参数的方法不同">不同点 : apply和call接受参数的方法不同</h2><p><strong>apply接受的是数组参数，call接受的是连续参数</strong></p><p>**apply **</p><p>接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。 语法：apply([thisObj [,argArray] ])</p><p>说明：如果argArray不是一个有效数组或不是arguments对象，那么将导致一个 TypeError，如果没有提供argArray和thisObj任何一个参数，那么Global对象将用作thisObj。</p><p><strong>call</strong></p><p>与apply相似，第一个参数是函数运行的作用域，但另一个参数数组需要列举。 语法：call([thisObject[,arg1 [,arg2 [,...,argn]]]])</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">color = <span class="string">'white'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Light</span>(<span class="params">mode, time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Lighting --- use color <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> in mode <span class="subst">$&#123;mode&#125;</span> at <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light();				</span><br><span class="line"><span class="comment">//Lighting --- use color white in mode undefined at undefined</span></span><br><span class="line">Light.call(redLight, <span class="string">'low'</span>, <span class="string">'daylight'</span>);</span><br><span class="line"><span class="comment">//Lighting --- use color red in mode low at daylight</span></span><br><span class="line">Light.apply(blueLight, [<span class="string">'high'</span>, <span class="string">'night'</span>]);</span><br><span class="line"><span class="comment">//Lighting --- use color blue in mode high at night</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);				<span class="comment">//5</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);	<span class="comment">//5</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);			<span class="comment">//5 (es6)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
